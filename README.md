<p align="center">
<img src="https://github.com/ikozhuhar/ketov/blob/main/img/ketov-linux.png">
</p>

<details>
<p><summary><b> :large_blue_diamond: Глава 1. Архитектура ОС Linux</b></summary></p>

Архитектура ОС Linux состоит из трех уровней: **Уровень пользователя**, **Уровень Ядра** и **Аппаратный уровень**. Два главных режима работы: `kernel space` и `user space`. Главное отличие между уровнем пользователя и ядра состоит в привилегиях доступа к аппаратных ресурсам памяти и устройствам ввода-вывода, к которым разрешен полный доступ из режи­ма ядра и ограниченный доступ из режима пользователя.



#### :diamond_shape_with_a_dot_inside: _Компоненты User Space_

**Kernel space** обеспечивает распределение ресурсов между пользователями и предоставляет базовый интерфейс для доступ к ресурсам.

Функции ядра доступны в **user mode** с помощью системных вызовов. **Системные вызовы** выполняются в ядре, а вызывается из **user space** с помощью библиотеки **libc.so**. 

Функции выполняющиеся в **user space** доступны с помощью библиотечных вызовов и выполняются в самих библиотеках, например, **libz.so** и  **libbz2.so**



#### :diamond_shape_with_a_dot_inside: _Компоненты Ядра_

Компоненты Ядра в основном обеспечивают распределение ресурсов, что приводит к появлению **менеджеров** или под­систем управления _процессов_, _памяти_, _ввода-вывода_ и _менеджера файловой системы_.

- **Менеджер (подсистема) процессов** распределяет время ЦП между выполняющимися задачами.

- **Менеджер (подсистема) ввода-вывода** распределяет доступ к устройствам ввода-вывода между процессоми.

- **Менеджер (подсистема) памяти** распределяет пространство ОЗУ между процессами.

- **Файловый (подсистема) Менеджер** предоставляет процессам интерфейс файлового доступа к дискам (hdd). **Особое значение** менеджера файлов состоит в том, что с помощью файлового интерфейса процессам предоставляется доступ к другим подсистемам. Например, доступ к CD/DVD-накопителя через `/dev/sr0`, к мыши через `/dev/input/mouse`. Доступ к физ памяти через /dev/mem, доступ процессов к страницам памяти друг друга через `/proc/PID/mem`, а доступ к обнаруженным Ядром устройств через псевдофайловую систему `sysfs` каталога `/sys`.

Кроме указанных задач все менеджеры в совокупности предоставляют процессам средства межпроцессорного взаимодействия, такие как **сигналы**, **каналы**, **сокеты** и **разделяемая память**.



#### :diamond_shape_with_a_dot_inside: _Аппаратный уровень_

**Аппаратный уровень** состоит из всех периферийных устройств, таких как оперативная память, жесткий диск, процессор и т.д.



#### :diamond_shape_with_a_dot_inside: _Трассировка системных и библиотечных вызовов_

Для наблюдения за обращениями программ к услугам ядера, т. е. за системными вызовами, служит утилита `strace`, предна­значенная для трассировки — построения трасс выполнения той или иной программы.

![image](https://github.com/user-attachments/assets/b737c689-cfc7-49db-93cd-9d501537e0f0)



#### :diamond_shape_with_a_dot_inside: _Резюме_

Архитектура ОС Linux состоит из трех уровней: уровня пользователя, уровня ядра и аппаратного уровня. Уровни взаимодействуют между собой с помощью интерфейсов. В качестве интерфейса между уровнем пользователя и уровнем ядра выступают - **системные вызовы**. Они позволяют программам выполнять низкоуровневые операции, которые требуют привилегий ядра.

**Примеры системных вызовов:**

**Файловые операции**: open() (открытие файла), read() (чтение данных из файла), write() (запись данных в файл), close() (закрытие файла).  
**Процессные операции**: fork() (создание нового процесса путём клонирования текущего процесса), exec() (замена текущего процесса новым процессом), wait() (ожидание завершения дочернего процесса).  
**Операции с памятью**: brk() (изменение размера сегмента данных процесса), mmap() (отображение файлов или устройств в память).  
**Сетевые операции**: socket() (создание нового сокета), bind() (привязка сокета к адресу), listen() (ожидание соединений на сокете), accept() (принятие входящего соединения).

Интерфейсом между уровнем ядра и аппаратным уровнем выступают **драйверы устройств**. Ядро обрабатывает аппаратные прерывания, сигналы, поступающие от периферии, процессора, памяти и так далее. Кроме того, **система управления устройствами** на уровне ядра действует как низкоуровневый интерфейс между оборудованием и операционной системой.

![image](https://github.com/user-attachments/assets/d8cda107-d0c9-4377-93d7-7f70d5fd13a3)
![image](https://github.com/user-attachments/assets/65ec448f-06e7-4233-a62c-4e3f927dbf5b)
![image](https://github.com/user-attachments/assets/9ec41b9e-aef4-48fb-b026-068bc4871735)


</details>



<details>
<p><summary><b> :large_blue_diamond: Глава 2. Пользовательское окружение ОС Linux</b></summary></p>

На персональных ПК, для взаимодействия с пользователем используется клавиатура, видео-адаптер и монитор, которые формируют консоль. Консоль используется драйвером виртуальных интерфейсов для организации нескольких физических терминалов.

Узнать имя текущего терминала (а точнее, имя спец файла устройства) можно командой `tty`, а список всех терминальных входов пользователей - команды `users`, `who`, `w`.

![image](https://github.com/user-attachments/assets/f2ee75e7-aa0e-4f72-98d2-193ef98d287b)
![image](https://github.com/user-attachments/assets/865566e4-7a8f-40fe-9126-f8bb68870b40)

### Пользователи и группы

```ruby
finger ikozhuhar
```

![image](https://github.com/user-attachments/assets/5cba7054-6762-47c1-8386-d48d57eec97b)


<br/>

### Подсистема управления файлами и вводом-выводом

Linux, базируются на одной универсальной идее о том, что информация есть файл, откуда бы эта информация в систему ни поступала. При помощи файлов обеспечивается доступ к информации на устройствах хранения, к информации с устройств связи принимаемой в реальном времени, информации из любых других источников.

- **Одни файлы обеспечивают доступ к информации**, хранимой на разнообразных носителях: магнитных дисках и дискетах, оптических CD/DVD/BD, твердотельных «дисках» и пр.
- **Другие файлы обеспечивают доступ к информации**, поступающей из/в устройств ввода-вывода — клавиатур, манипуляторов «мышь», тачпадов, сенсорных экранов, последовательных и параллельных портов, видеокамер, звуковых карт и пр.
- **Особенные файлы обеспечивают доступ к информации** о сущностях ядра операционной системы (процессы, нити, модули, драйвера и пр.).

<br/>

### Путевые имена файлов

Например, 
- Каталог `/bin (binary)` предназначен для системных программ общего назначения.
- Каталог `/usr/bin` - предназначен для прикладных программ общего назначения.
- Каталог `/usr/local/bin` - предназначен для локально установленных прикладных программ общего назначения, а каталог `bin` внутри домашних каталогов пользователей - для программ персонального назначения.
- Каталоги `/sbin`, `/usr/sbin`, `/usr/local/sbin` - предназначены для программ системного администрирования, системных прикладных, и локально установленных. Расшифровываются каталоги как `superuser binary`.
- Каталог `/home` является контейнером домашних каталогов пользователей.
- Каталог `/var` предназначен для динамических данных таких как логи и почта, а каталог `/tmp` для временных файлов.
- Каталоги `/dev`, `/proc`, `/sys` содержат специальные файлы устройств и файлы псевдофайловых систем `proc` и `sysfs`

<br />

### Типы файлов

Файлы различаются по типам указывающим источник информации:

- **Обычные файлы** и каталоги обеспечивают хранение информации на разных носителях.
- **Специальные файлы** позволяют обмениватся информацией с разными аппаратными устройствами ввода-вывода.
- **Именнованые каналы и файловые сокеты** предназначены для обмена информацией между процессом одной программы и процессами других программ.

Символом `-` обозначается обычный файл, символом `b` или `с` — специальные файлы блочного (`block`) или символьного (`character`) устройства, символом `р` — именованный канал (`pipe`), символом `s` - сокет (socket), а символом `I` — символическая ссылка (`link`).

**Обычные файлы** хранят в себе пользовательскую информацию: текст, изображения, звук, видео и прочие данные в виде набора байтов.

```
file /usr/share/man/man1/file.1.gz
file 72fc0484-9d38-4743-a48f-97bcf4caf061.jpeg
```

![image](https://github.com/user-attachments/assets/caf8ff09-ac5a-4b17-9c42-5e93cb4a342c)


**Каталоги** в отличии от файлов содержат в себе таблицу имен файлов и соответствующих им номеров индексных дескрипторов (`inode`). Каждый `inode` содержит метаданные и список стандартных свойств файла и его местоположение в файловой системе. Полный набор метаданных позволяет получить команда `stat`.

```
ls -ai
stat .profile
```

![image](https://github.com/user-attachments/assets/a5c3408b-66fa-4788-9f6f-68464c78a501)

<br>

### Ссылки

**Жёсткая ссылка** это два разных имени указывающие на одни и те же метаданные. При добавлении нового имени файла в метаданных увеличивается счётчик количества имён. При удалении, сначала удаляется имя файла, потом именьшается счётчик и только после этого высвобожжаются метаданные. Удаление не происходит _вообще_ если у файла остались имена (жёсткие сылки) и не происходит сразу если файл открыт каким-то процессом. Помиотреть кем открыт файл можно командой `lsof astra-linux-l.3-special-edition-snolensk-disk3-devel.iso`

**Чтобы создать жёсткую ссылку в Linux, нужно использовать команду ln без опции -s.**

Синтаксис команды: `ln целевой_файл имя_жёсткой_ссылки.`

Например, чтобы создать жёсткую ссылку с именем `hardlinktofile` на файл `myfile.txt`, нужно выполнить команду `ln myfile.txt hardlinktofile`.

Ограничением жёсткой ссылки является её локальность в рамках своей файловой системы в силу значимости номеров индексных дескрипторов(`inode`).

Для преодоления этого ограничения существуют символические ссылки, которые содержат в себе путевое имя к целевого файлу. В случае удаления целевого файла символическая ссылка будет указывать в _никуда_ и называться **сиротой**.

**Чтобы создать символическую ссылку в Linux, нужно использовать команду ln с опцией -s.**

**Для создания ссылки на файл** нужно открыть терминал и ввести команду: `ln -s source_file symbolic_link`. В строке `source_file` указать имя существующего файла, для которого нужно создать символическую ссылку, а `symbolic_link` — имя самой ссылки. Если не указать второе имя, команда `ln` создаст новую ссылку в текущей папке.

**Для создания ссылки на папку** команда такая же, только первым параметром указывается имя папки, а вторым — ссылка. Например, чтобы создать символическую ссылку из папки `/mnt/my_drive/movies` в папку `~/my_movies`, нужно ввести `ln -s /mnt/my_drive/movies ~/my_movies`.

Чтобы убедиться, что символическая ссылка создана успешно, можно ввести команду `ls -l symbolic_link`. 






</details>
