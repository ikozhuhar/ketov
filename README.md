<p align="center">
<img src="https://github.com/ikozhuhar/ketov/blob/main/img/ketov-linux.png">
</p>

<details>
<p><summary><b> :large_blue_diamond: ГЛАВА 1. Архитектура ОС Linux</b></summary></p>

Архитектура ОС Linux состоит из трех уровней: **Уровень пользователя**, **Уровень Ядра** и **Аппаратный уровень**. Два главных режима работы: `kernel space` и `user space`. Главное отличие между уровнем пользователя и ядра состоит в привилегиях доступа к аппаратных ресурсам памяти и устройствам ввода-вывода, к которым разрешен полный доступ из режи­ма ядра и ограниченный доступ из режима пользователя.



#### :diamond_shape_with_a_dot_inside: _Компоненты User Space_

**Kernel space** обеспечивает распределение ресурсов между пользователями и предоставляет базовый интерфейс для доступ к ресурсам.

Функции ядра доступны в **user mode** с помощью системных вызовов. **Системные вызовы** выполняются в ядре, а вызывается из **user space** с помощью библиотеки **libc.so**. 

Функции выполняющиеся в **user space** доступны с помощью библиотечных вызовов и выполняются в самих библиотеках, например, **libz.so** и  **libbz2.so**



#### :diamond_shape_with_a_dot_inside: _Компоненты Ядра_

Компоненты Ядра в основном обеспечивают распределение ресурсов, что приводит к появлению **менеджеров** или под­систем управления _процессов_, _памяти_, _ввода-вывода_ и _менеджера файловой системы_.

- **Менеджер (подсистема) процессов** распределяет время ЦП между выполняющимися задачами.

- **Менеджер (подсистема) ввода-вывода** распределяет доступ к устройствам ввода-вывода между процессоми.

- **Менеджер (подсистема) памяти** распределяет пространство ОЗУ между процессами.

- **Файловый (подсистема) Менеджер** предоставляет процессам интерфейс файлового доступа к дискам (hdd). **Особое значение** менеджера файлов состоит в том, что с помощью файлового интерфейса процессам предоставляется доступ к другим подсистемам. Например, доступ к CD/DVD-накопителя через `/dev/sr0`, к мыши через `/dev/input/mouse`. Доступ к физ памяти через /dev/mem, доступ процессов к страницам памяти друг друга через `/proc/PID/mem`, а доступ к обнаруженным Ядром устройств через псевдофайловую систему `sysfs` каталога `/sys`.

Кроме указанных задач все менеджеры в совокупности предоставляют процессам средства межпроцессорного взаимодействия, такие как **сигналы**, **каналы**, **сокеты** и **разделяемая память**.



#### :diamond_shape_with_a_dot_inside: _Аппаратный уровень_

**Аппаратный уровень** состоит из всех периферийных устройств, таких как оперативная память, жесткий диск, процессор и т.д.



#### :diamond_shape_with_a_dot_inside: _Трассировка системных и библиотечных вызовов_

Для наблюдения за обращениями программ к услугам ядера, т. е. за системными вызовами, служит утилита `strace`, предна­значенная для трассировки — построения трасс выполнения той или иной программы.

![image](https://github.com/user-attachments/assets/b737c689-cfc7-49db-93cd-9d501537e0f0)



#### :diamond_shape_with_a_dot_inside: _Резюме_

Архитектура ОС Linux состоит из трех уровней: уровня пользователя, уровня ядра и аппаратного уровня. Уровни взаимодействуют между собой с помощью интерфейсов. В качестве интерфейса между уровнем пользователя и уровнем ядра выступают - **системные вызовы**. Они позволяют программам выполнять низкоуровневые операции, которые требуют привилегий ядра.

**Примеры системных вызовов:**

**Файловые операции**: open() (открытие файла), read() (чтение данных из файла), write() (запись данных в файл), close() (закрытие файла).  
**Процессные операции**: fork() (создание нового процесса путём клонирования текущего процесса), exec() (замена текущего процесса новым процессом), wait() (ожидание завершения дочернего процесса).  
**Операции с памятью**: brk() (изменение размера сегмента данных процесса), mmap() (отображение файлов или устройств в память).  
**Сетевые операции**: socket() (создание нового сокета), bind() (привязка сокета к адресу), listen() (ожидание соединений на сокете), accept() (принятие входящего соединения).

Интерфейсом между уровнем ядра и аппаратным уровнем выступают **драйверы устройств**. Ядро обрабатывает аппаратные прерывания, сигналы, поступающие от периферии, процессора, памяти и так далее. Кроме того, **система управления устройствами** на уровне ядра действует как низкоуровневый интерфейс между оборудованием и операционной системой.

![image](https://github.com/user-attachments/assets/d8cda107-d0c9-4377-93d7-7f70d5fd13a3)
![image](https://github.com/user-attachments/assets/65ec448f-06e7-4233-a62c-4e3f927dbf5b)
![image](https://github.com/user-attachments/assets/9ec41b9e-aef4-48fb-b026-068bc4871735)

</details>





<details>
<p><summary><b> :large_blue_diamond: ГЛАВА 2. Пользовательское окружение ОС Linux</b></summary></p>

На персональных ПК, для взаимодействия с пользователем используется клавиатура, видео-адаптер и монитор, которые формируют консоль. Консоль используется драйвером виртуальных интерфейсов для организации нескольких физических терминалов.

Узнать имя текущего терминала (а точнее, имя спец файла устройства) можно командой `tty`, а список всех терминальных входов пользователей - команды `users`, `who`, `w`.

![image](https://github.com/user-attachments/assets/f2ee75e7-aa0e-4f72-98d2-193ef98d287b)
![image](https://github.com/user-attachments/assets/865566e4-7a8f-40fe-9126-f8bb68870b40)

### Пользователи и группы

```ruby
finger ikozhuhar
```

![image](https://github.com/user-attachments/assets/5cba7054-6762-47c1-8386-d48d57eec97b)

</details>






<details>
<p><summary><b> :large_blue_diamond: ГЛАВА 3. Подсистема управления файлами и вводом-выводом</b></summary></p>

Linux, базируются на одной универсальной идее о том, что информация есть файл, откуда бы эта информация в систему ни поступала. При помощи файлов обеспечивается доступ к информации на устройствах хранения, к информации с устройств связи принимаемой в реальном времени, информации из любых других источников.

- **Одни файлы обеспечивают доступ к информации**, хранимой на разнообразных носителях: магнитных дисках и дискетах, оптических CD/DVD/BD, твердотельных «дисках» и пр.
- **Другие файлы обеспечивают доступ к информации**, поступающей из/в устройств ввода-вывода — клавиатур, манипуляторов «мышь», тачпадов, сенсорных экранов, последовательных и параллельных портов, видеокамер, звуковых карт и пр.
- **Особенные файлы обеспечивают доступ к информации** о сущностях ядра операционной системы (процессы, нити, модули, драйвера и пр.).

<br/>

### 3.1 Путевые имена файлов

Например, 
- Каталог `/bin (binary)` предназначен для системных программ общего назначения.
- Каталог `/usr/bin` - предназначен для прикладных программ общего назначения.
- Каталог `/usr/local/bin` - предназначен для локально установленных прикладных программ общего назначения, а каталог `bin` внутри домашних каталогов пользователей - для программ персонального назначения.
- Каталоги `/sbin`, `/usr/sbin`, `/usr/local/sbin` - предназначены для программ системного администрирования, системных прикладных, и локально установленных. Расшифровываются каталоги как `superuser binary`.
- Каталог `/home` является контейнером домашних каталогов пользователей.
- Каталог `/var` предназначен для динамических данных таких как логи и почта, а каталог `/tmp` для временных файлов.
- Каталоги `/dev`, `/proc`, `/sys` содержат специальные файлы устройств и файлы псевдофайловых систем `proc` и `sysfs`

<br />

### 3.2 Типы файлов

Файлы различаются по типам указывающим источник информации:

- **Обычные файлы** и каталоги обеспечивают хранение информации на разных носителях.
- **Специальные файлы** позволяют обмениватся информацией с разными аппаратными устройствами ввода-вывода.
- **Именнованые каналы и файловые сокеты** предназначены для обмена информацией между процессом одной программы и процессами других программ.

Символом `-` обозначается обычный файл, символом `b` или `с` — специальные файлы блочного (`block`) или символьного (`character`) устройства, символом `р` — именованный канал (`pipe`), символом `s` - сокет (socket), а символом `I` — символическая ссылка (`link`).

**Обычные файлы** хранят в себе пользовательскую информацию: текст, изображения, звук, видео и прочие данные в виде набора байтов.

```ruby
file /usr/share/man/man1/file.1.gz
file 72fc0484-9d38-4743-a48f-97bcf4caf061.jpeg
```

![image](https://github.com/user-attachments/assets/caf8ff09-ac5a-4b17-9c42-5e93cb4a342c)


**Каталоги** в отличии от файлов содержат в себе таблицу имен файлов и соответствующих им номеров индексных дескрипторов (`inode`). Каждый `inode` содержит метаданные и список стандартных свойств файла и его местоположение в файловой системе. Полный набор метаданных позволяет получить команда `stat`.

```ruby
ls -ai
stat .profile
```

![image](https://github.com/user-attachments/assets/a5c3408b-66fa-4788-9f6f-68464c78a501)

<br>

### Ссылки

**Жёсткая ссылка** это два разных имени указывающие на одни и те же метаданные. При добавлении нового имени файла в метаданных увеличивается счётчик количества имён. При удалении, сначала удаляется имя файла, потом именьшается счётчик и только после этого высвобожжаются метаданные. Удаление не происходит _вообще_ если у файла остались имена (жёсткие сылки) и не происходит сразу если файл открыт каким-то процессом. Помиотреть кем открыт файл можно командой `lsof astra-linux-l.3-special-edition-snolensk-disk3-devel.iso`

**Чтобы создать жёсткую ссылку в Linux, нужно использовать команду ln без опции -s.**

Синтаксис команды: `ln целевой_файл имя_жёсткой_ссылки.`

Например, чтобы создать жёсткую ссылку с именем `hardlinktofile` на файл `myfile.txt`, нужно выполнить команду `ln myfile.txt hardlinktofile`.

Ограничением жёсткой ссылки является её локальность в рамках своей файловой системы в силу значимости номеров индексных дескрипторов(`inode`).

Для преодоления этого ограничения существуют символические ссылки, которые содержат в себе путевое имя к целевого файлу. В случае удаления целевого файла символическая ссылка будет указывать в _никуда_ и называться **сиротой**.

**Чтобы создать символическую ссылку в Linux, нужно использовать команду ln с опцией -s.**

**Для создания ссылки на файл** нужно открыть терминал и ввести команду: `ln -s source_file symbolic_link`. В строке `source_file` указать имя существующего файла, для которого нужно создать символическую ссылку, а `symbolic_link` — имя самой ссылки. Если не указать второе имя, команда `ln` создаст новую ссылку в текущей папке.

**Для создания ссылки на папку** команда такая же, только первым параметром указывается имя папки, а вторым — ссылка. Например, чтобы создать символическую ссылку из папки `/mnt/my_drive/movies` в папку `~/my_movies`, нужно ввести `ln -s /mnt/my_drive/movies ~/my_movies`.

Чтобы убедиться, что символическая ссылка создана успешно, можно ввести команду `ls -l symbolic_link`. 

<br>

### Специальные файлы устройств

Специальные файлы предназначены для ввода и вывода данных с аппаратных устройств. Настоящую работу по вводу-выводу делает **драйвер**, а специальные файлы являются "порталами" связи с драйверами. Различают символьные и блочные специальные файлы устройств.

**Блочные специальные файлы** — это тип файлов в UNIX-подобных операционных системах, которые обеспечивают буферизованный доступ к аппаратным компонентам, таким как жёсткие диски, съёмные носители и т.д..

Они используются для передачи данных, разделённых на пакеты фиксированной длины — блоки, размером 512, 1024, 4096 или 8192 байтов. Типичным примером подобных устройств являются магнитные диски.

В Linux **блочные файлы** обозначаются буквой `b`, а символьные — буквой `c`. Они находятся в каталоге `/dev` (`от англ. devices — устройства`), который содержит интерфейсы работы с драйверами ядра. 

**Символьные специальные файлы** обеспечивают небуферизованный доступ к ядру и аппаратным компонентам, таким как клавиатура, монитор, принтеры. Это значит, что они могут передавать за раз лишь один символ.

Примерами таких устройств являются терминалы (в том числе, системная консоль), последовательные устройства, некоторые виды магнитных лент.

Для символьных файлов предусмотрена буква `c (character)`. Определить их можно по первому символу в выводе команды `ls -l`.

Специальные файлы не хранят данные на диске, а только передают их между процессами и устройствами. Поэтому размер специальных файлов всегда равен нулю.

**Все драйверы ядра** пронумерованы главными (`major`) числами, а аппаратные устройства, находящиеся под их управлением, дополнительными (`minor`) числами.

**Major и minor числа нужны для идентификации устройств в операционной системе Linux.**

![image](https://github.com/user-attachments/assets/6cfc4b0f-24a3-4b9e-988a-bbe5d32f2d55)

https://www.kernel.org/doc/Documentation/admin-guide/devices.txt

**Major число** указывает, какой драйвер используется для доступа к оборудованию. Каждому драйверу назначается уникальный `major` номер, все файлы устройств с одинаковым `major` номером управляются одним и тем же драйвером.

**Minor число** используется драйвером для различения между различными устройствами, которые он контролирует. Например, если у жёсткого диска четыре раздела, то у каждого раздела будут отдельные `minor` номера, в то время как `major` число будет одним, потому что для всех разделов используется один и тот же драйвер хранилища.

Таким образом, **major число определяет тип устройства, а minor число — конкретное устройство в рамках этого типа**. 

```ruby
# Показывает драйверы и другие модули, которые загружены в данный момент
lsmod

# Информация о заданном модуле
modinfo
```

<br>

### Именованные каналы и файловые сокеты

Именованные каналы и файловые сокеты являются простейшими средствами межпроцессного взаимодействия (IPC, InterProcess Communication) и служат программам для обмена информацией между собой.

**Каналы и сокеты** используют для передачи данных от процесса к процессу оперативную память ядра операционной системы, а не память накопителя, как обычные файлы.

Основное отличие **именованного канала** от **сокета** состоит в способе передачи данных. Через именованный канал организуется однонаправленная (симплексная) передача без мультиплексирования, а через сокет — двунаправленная (дуплексная) мультиплексированная передача.

**Именованный канал** обычно используют при взаимодействии процессов по схеме «поставщик — потребитель» (producer-consumer), когда один потребитель принимает информацию от одного поставщика. Например, программы `halt(8)`, `shutdown(8)`, `reboot(8)`, `poweroff(8)` и `telinit(8)` передавали ранее посредством именованного канала `/dev/initctl` команды перезагрузки, выключения питания и другие диспетчеру `init(8)1`, который и выполнял соответствующие действия.

**Сокет используют** при взаимодействии по схеме «клиент — сервер» (client-server), т. е. один сервер принимает и отправляет информацию от многих и ко многим (одновременно) клиентам. Например, в целях сбора событий, службы операционной системы `сгоn(8)`, служба печати `cupsd(8)` и `logger(1)` передают посредством файлового сокета `/dev/log` сообщения о событиях службе журнализации `systemd-journald(8)`.

<br>

### 3.3 Файловые дескрипторы

**Файловый дескриптор — это натуральное число, которое является идентификатором потока ввода-вывода**. Дескриптор может быть связан с файлом, каталогом, сокетом. 

Основными операциями, предоставляемыми ядром программам для работы с файлами, являются системные вызовы (интерфейсами) `open(2)`, `read(2)`, `write(2)` и `close(2)`. Эти системные вызовы предназначены для открытия и закрытия файла, для чтения из файла и записи в файл. Дополнительный системный вызов `ioctl(2) (input output control)` используется для управления драйверами устройств и, как следствие, применяется в основном для специальных файлов устройств.

При запросе процесса на открытие файла системным вызовом `ореn(2)` для запросившего процесса создается так называемый **файловый дескриптор** (описатель, от англ, descriptor). Файловый дескриптор «содержит» информацию, описывающую файл, например `inode` файла, номера `major` и `minor` устройства, на котором располагается файловая система файла, режим открытия файла и прочую служебную информа­ цию. При последующих операциях `read(2)` и `write(2)` доступ к самим данным файла происходит с использованием файлового дескриптора.

Когда процесс открывает файл или устройство, операционная система создаёт дескриптор файла для отслеживания открытого ресурса. Этот дескриптор служит ссылкой, через которую процесс может читать, записывать или управлять этим ресурсом.

По умолчанию Unix-оболочки связывают файловый дескриптор `0` с потоком стандартного ввода (клавиатура), файловый дескриптор `1` — с потоком стандартного вывода (терминал), и файловый дескриптор `2` — со стандартным выводом ошибок (диагностические и отладочные сообщения, информация об ошибках). 

```ruby
lsof -p $$
```

![image](https://github.com/user-attachments/assets/12ab8a1f-f18c-405b-bea3-ca741dee8246)

<br>

### 3.4 Файловые системы

</details>





<details>
<p><summary><b> :large_blue_diamond: ГЛАВА 4. Управление процессами и памятью</b></summary></p>



</details>
